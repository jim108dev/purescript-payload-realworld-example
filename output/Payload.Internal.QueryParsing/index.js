// Generated by purs version 0.13.8
"use strict";
var Data_Eq = require("../Data.Eq/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Symbol = require("../Data.Symbol/index.js");
var Key = (function () {
    function Key(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Key.create = function (value0) {
        return function (value1) {
            return new Key(value0, value1);
        };
    };
    return Key;
})();
var Multi = (function () {
    function Multi(value0) {
        this.value0 = value0;
    };
    Multi.create = function (value0) {
        return new Multi(value0);
    };
    return Multi;
})();
var QueryListProxy = (function () {
    function QueryListProxy() {

    };
    QueryListProxy.value = new QueryListProxy();
    return QueryListProxy;
})();
var ToSegments = function (toSegments) {
    this.toSegments = toSegments;
};
var ParseQuery = {};
var ParseError = {};
var Match = {};
var toSegmentsQueryNil = new ToSegments(function (v) {
    return function (acc) {
        return acc;
    };
});
var toSegments = function (dict) {
    return dict.toSegments;
};
var toSegmentsConsKey = function (dictIsSymbol) {
    return function (dictIsSymbol1) {
        return function (dictToSegments) {
            return new ToSegments(function (v) {
                return function (segs) {
                    var nameStr = Data_Symbol.reflectSymbol(dictIsSymbol)(Data_Symbol.SProxy.value);
                    var keyStr = Data_Symbol.reflectSymbol(dictIsSymbol1)(Data_Symbol.SProxy.value);
                    return toSegments(dictToSegments)(QueryListProxy.value)(new Data_List_Types.Cons(new Key(nameStr, keyStr), segs));
                };
            });
        };
    };
};
var toSegmentsConsMulti = function (dictIsSymbol) {
    return function (dictToSegments) {
        return new ToSegments(function (v) {
            return function (segs) {
                var multiStr = Data_Symbol.reflectSymbol(dictIsSymbol)(Data_Symbol.SProxy.value);
                return toSegments(dictToSegments)(QueryListProxy.value)(new Data_List_Types.Cons(new Multi(multiStr), segs));
            };
        });
    };
};
var switchToKeyEquals = function (dictCons) {
    return function (dictMatch) {
        return Match;
    };
};
var switchKeyToMulti = function (dictCons) {
    return function (dictCons1) {
        return function (dictMatch) {
            return Match;
        };
    };
};
var startQuestionMark = function (dictCons) {
    return function (dictMatch) {
        return Match;
    };
};
var startMulti = function (dictCons) {
    return function (dictCons1) {
        return function (dictCons2) {
            return function (dictMatch) {
                return Match;
            };
        };
    };
};
var startLit = function (dictCons) {
    return function (dictMatch) {
        return Match;
    };
};
var skipNonQuestionMarkAtStart = function (dictCons) {
    return function (dictMatch) {
        return Match;
    };
};
var skipInBetweenAmpersand = function (dictCons) {
    return function (dictMatch) {
        return Match;
    };
};
var showSegment = new Data_Show.Show(function (v) {
    if (v instanceof Key) {
        return "(Key " + (v.value0 + ("=<" + (v.value1 + ">)")));
    };
    if (v instanceof Multi) {
        return "(Multi '" + (v.value0 + "')");
    };
    throw new Error("Failed pattern match at Payload.Internal.QueryParsing (line 21, column 1 - line 23, column 43): " + [ v.constructor.name ]);
});
var parseError = function (dictFail) {
    return function (dictAppend) {
        return function (dictPrintArrow) {
            return ParseError;
        };
    };
};
var keyEquals = function (dictCons) {
    return function (dictMatch) {
        return Match;
    };
};
var failedKeyEquals = function (dictParseError) {
    return Match;
};
var failTrailingAmpersand = function (dictParseError) {
    return Match;
};
var failSplitLit = function (dictParseError) {
    return Match;
};
var failOpenKeyWithoutEquals = function (dictParseError) {
    return Match;
};
var failNoSlashAtStart = function (dictCons) {
    return function (dictParseError) {
        return Match;
    };
};
var failNestedOpenMulti = function (dictParseError) {
    return Match;
};
var failNestedOpenKey = function (dictParseError) {
    return Match;
};
var failMissingMultiEnd = function (dictParseError) {
    return Match;
};
var failMissingKeyEnd = function (dictAppend) {
    return function (dictParseError) {
        return Match;
    };
};
var failMatch = function (dictFail) {
    return Match;
};
var failEndKeyWithoutStart = function (dictParseError) {
    return Match;
};
var failEndAtLit = function (dictParseError) {
    return Match;
};
var failEmptyQueryString = function (dictParseError) {
    return Match;
};
var failEmptyMulti = function (dictParseError) {
    return Match;
};
var failEmptyKey = function (dictParseError) {
    return Match;
};
var failContinueAfterMulti = function (dictParseError) {
    return Match;
};
var eqSegment = new Data_Eq.Eq(function (v) {
    return function (v1) {
        if (v instanceof Key && v1 instanceof Key) {
            return v.value0 === v1.value0 && v.value1 === v1.value1;
        };
        if (v instanceof Multi && v1 instanceof Multi) {
            return v.value0 === v1.value0;
        };
        return false;
    };
});
var ordSegment = new Data_Ord.Ord(function () {
    return eqSegment;
}, function (v) {
    return function (v1) {
        if (v instanceof Key && v1 instanceof Key) {
            var v2 = Data_Ord.compare(Data_Ord.ordString)(v.value0)(v1.value0);
            if (v2 instanceof Data_Ordering.EQ) {
                return Data_Ord.compare(Data_Ord.ordString)(v.value1)(v1.value1);
            };
            return v2;
        };
        if (v instanceof Multi && v1 instanceof Multi) {
            return Data_Ord.compare(Data_Ord.ordString)(v.value0)(v1.value0);
        };
        var rank = function (v2) {
            if (v2 instanceof Key) {
                return 1;
            };
            if (v2 instanceof Multi) {
                return 2;
            };
            throw new Error("Failed pattern match at Payload.Internal.QueryParsing (line 33, column 7 - line 33, column 25): " + [ v2.constructor.name ]);
        };
        return Data_Ord.compare(Data_Ord.ordInt)(rank(v))(rank(v1));
    };
});
var endWithEmptyNoQuestionMark = Match;
var endKey = function (dictCons) {
    return function (dictMatch) {
        return Match;
    };
};
var endAtMulti = Match;
var endAtKey = Match;
var contMulti = function (dictCons) {
    return function (dictAppend) {
        return function (dictMatch) {
            return Match;
        };
    };
};
var contLit = function (dictCons) {
    return function (dictAppend) {
        return function (dictMatch) {
            return Match;
        };
    };
};
var contKey = function (dictCons) {
    return function (dictAppend) {
        return function (dictMatch) {
            return Match;
        };
    };
};
var bConsParse = function (dictCons) {
    return function (dictMatch) {
        return ParseQuery;
    };
};
var asSegments = function (dictParseQuery) {
    return function (dictToSegments) {
        return function (v) {
            return Data_List.reverse(toSegments(dictToSegments)(QueryListProxy.value)(Data_List_Types.Nil.value));
        };
    };
};
var ampersandFail = function (dictParseError) {
    return Match;
};
var ampersand = function (dictCons) {
    return function (dictMatch) {
        return Match;
    };
};
var aNilParse = ParseQuery;
module.exports = {
    toSegments: toSegments,
    Key: Key,
    Multi: Multi,
    asSegments: asSegments,
    ToSegments: ToSegments,
    QueryListProxy: QueryListProxy,
    ParseQuery: ParseQuery,
    Match: Match,
    ParseError: ParseError,
    eqSegment: eqSegment,
    showSegment: showSegment,
    ordSegment: ordSegment,
    toSegmentsQueryNil: toSegmentsQueryNil,
    toSegmentsConsKey: toSegmentsConsKey,
    toSegmentsConsMulti: toSegmentsConsMulti,
    aNilParse: aNilParse,
    bConsParse: bConsParse,
    failTrailingAmpersand: failTrailingAmpersand,
    failEmptyQueryString: failEmptyQueryString,
    startQuestionMark: startQuestionMark,
    endWithEmptyNoQuestionMark: endWithEmptyNoQuestionMark,
    skipNonQuestionMarkAtStart: skipNonQuestionMarkAtStart,
    failNoSlashAtStart: failNoSlashAtStart,
    skipInBetweenAmpersand: skipInBetweenAmpersand,
    startMulti: startMulti,
    failEmptyMulti: failEmptyMulti,
    endAtMulti: endAtMulti,
    failContinueAfterMulti: failContinueAfterMulti,
    failMissingMultiEnd: failMissingMultiEnd,
    failNestedOpenMulti: failNestedOpenMulti,
    contMulti: contMulti,
    keyEquals: keyEquals,
    failedKeyEquals: failedKeyEquals,
    switchKeyToMulti: switchKeyToMulti,
    failEmptyKey: failEmptyKey,
    endAtKey: endAtKey,
    endKey: endKey,
    failMissingKeyEnd: failMissingKeyEnd,
    failNestedOpenKey: failNestedOpenKey,
    contKey: contKey,
    ampersand: ampersand,
    ampersandFail: ampersandFail,
    switchToKeyEquals: switchToKeyEquals,
    failEndKeyWithoutStart: failEndKeyWithoutStart,
    failOpenKeyWithoutEquals: failOpenKeyWithoutEquals,
    startLit: startLit,
    failSplitLit: failSplitLit,
    failEndAtLit: failEndAtLit,
    contLit: contLit,
    failMatch: failMatch,
    parseError: parseError
};
